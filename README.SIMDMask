# ===========================================================================
# 
# README.SIMDMask
# notes on SIMDMask extension
# Author: Markus Vieth (Bielefeld University, mvieth@techfak.uni-bielefeld.de)
# Year of creation: 2019
#
# This file is part of the following software:
# 
#    - the low-level C++ template SIMD library
#    - the SIMD implementation of the MinWarping and the 2D-Warping methods 
#      for local visual homing.
# 
# The software is provided based on the accompanying license agreement
# in the file LICENSE or LICENSE.doc. The software is provided "as is"
# without any warranty by the licensor and without any liability of the
# licensor, and the software may not be distributed by the licensee; see
# the license agreement for details.
# 
# (C) Markus Vieth, Ralf MÃ¶ller
#     Computer Engineering
#     Faculty of Technology
#     Bielefeld University
#     www.ti.uni-bielefeld.de
# 
# ===========================================================================

Every unmasked function has two masked counterparts: masked with a
specific source (mask_*, e.g. mask_add) and masked with zero-source
(maskz_*, e.g. maskz_add). For the "mask_*"-functions, the first
parameter is a vector and the second is the mask. For the
"maskz_*"-functions the first vector-parameter is dropped so the mask
is the first parameter. The following parameters are the same as for
the unmasked functions. Two exceptions are mask_store, where there is
no maskz_store, and mask_ifelse, where there is no maskz_ifelse.

There are new functions that operate on masks, i.e. masks as
parameters and return values. These functions have similar naming and
format as the Intel-intrinsics (e.g. kand, kor, knot). The
shift-functions (kshiftli, kshiftri) have two forms: one with the
shift count as a normal parameter, and one with the shift count as a
template parameter. The former is more flexible, while the latter is
probably faster.

The "cmp*"-functions (cmplt, cmple, cmpgt, cmpge, cmpeq, cmpneq) have
"mask_cmp*" counterparts, which return SIMDMasks instead of
SIMDVecs. The Intel-intrinsics do this the same way.

The masks are either based on the Intel mask types (AVX512, only
SIMDVecMaskImplIntel64.H), or emulated. The emulation consists of a vector,
of the same type as SIMDVec (e.g. __m256i for all Intel32 integer
masks, __m256 for Intel32 float masks, uint8x16_t for Neon16 Byte
masks). If a mask field should be true (or "1", "set"), the
corresponding vector element consists of all ones, else of all zeros.

The SIMDMask-classes have the operators "[]", to test whether a mask
field at a given index is true (or "1", "set"), and "==", to test
whether two SIMDMasks are equal.

The emulated masked functions use ifelse (i.e. the underlying
blend). For float functions, the "maskz_*"-functions mask the
operator(s) to a non-critical value (usually 0), so that no exceptions
(e.g. divide by zero) arise when they should not. the
"mask_*"-functions use the "maskz_*"-functions with an additional
ifelse for the output.

SIMDVecMaskImplEmu.H contains the emulated mask functions, without any
architecture-specific intrinsics.

SIMDVecMaskImplIntel16.H, SIMDVecMaskImplIntel32.H, and SIMDMaskNeon16.H contain,
other than the class definitions, functions that need
architecture-specific intrinsics (mask_all_ones, maskz_load, and
mask_store).

SIMDVecMaskImplIntel64.H contains the class definitions and functions for the
64 byte (512 bit) masks. This is standalone, meaning no dependency on
SIMDVecMaskImplEmu.H. The masked intrinsics are used whenever available. One
notable exception is when AVX512BW is not available, so the intrinsics
for Byte, SignedByte, Word, and Short are not available either. Then
emulations are used.

No masked variant exist for these functions: reinterpret, setzero,
extract, unpack, zip, unzip, packs, extend, elem0, alignre, swizzle,
unswizzle, convert, transpose, avgrd,

Ideas:

- "reinterpret" or "cast" function for masks (SIMDByte to
  SIMDSignedByte and vice versa, SIMDWord to SIMDShort and vice versa,
  SIMDInt to SIMDFloat and vice versa) (partly implemented in
  SIMDVecMaskImplEmu.H)

- []-operator to set mask fields, e.g. mask[2]=false or
  mask[5]=true. Is this possible?
